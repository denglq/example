<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>pthread_rwlock_fcfs_alloc, 
pthread_rwlock_fcfs_gain_read, pthread_rwlock_gain_w</title>
	<meta name="description" content="Pod documentation for pthread_rwlock_fcfs_alloc, 
pthread_rwlock_fcfs_gain_read, pthread_rwlock_gain_w" />
	<meta name="inputfile" content="/home/shlomi/progs/C/pthreads/rwlock/trunk/pthreads/man/pthread_rwlock_fcfs.pod" />
	<meta name="outputfile" content="pthread_rwlock_fcfs.html" />
	<meta name="created" content="Thu Apr 16 14:32:10 2009" />
	<meta name="generator" content="Pod::Xhtml 1.59" />
</head>
<body>
<div class="pod">
<h1 id="NAME">NAME</h1><p><a href="#TOP" class="toplink">Top</a></p>
<div id="NAME_CONTENT">
<p>pthread_rwlock_fcfs_alloc, 
pthread_rwlock_fcfs_gain_read, pthread_rwlock_gain_write, 
pthread_rwlock_fcfs_timed_gain_read, pthread_rwlock_fcfs_timed_gain_write,
pthread_rwlock_fcfs_try_gain_read, pthread_rwlock_fcfs_try_gain_write,
pthread_rwlock_fcfs_release,
pthread_rwlock_fcfs_destroy - operations on a first-come first-served 
readers/writers lock.</p>





</div>
<h1 id="SYNOPSIS">SYNOPSIS</h1><p><a href="#TOP" class="toplink">Top</a></p>
<div id="SYNOPSIS_CONTENT">
<p><strong>#include &lt;pthread/rwlock_fcfs.h&gt;</strong></p>
<p><strong>pthread_rwlock_fcfs_t</strong> * <i>rwlock</i> = <strong>pthread_rwlock_fcfs_alloc</strong>();</p>
<p><strong>int</strong> <strong>pthread_rwlock_fcfs_gain_read</strong>(<strong>pthread_rwlock_fcfs_t</strong> * <i>rwlock</i>);</p>
<p><strong>int</strong> <strong>pthread_rwlock_fcfs_gain_write</strong>(<strong>pthread_rwlock_fcfs_t</strong> * <i>rwlock</i>);</p>
<p><strong>int</strong> <strong>pthread_rwlock_fcfs_try_gain_read</strong>(<strong>pthread_rwlock_fcfs_t</strong> * <i>rwlock</i>);</p>
<p><strong>int</strong> <strong>pthread_rwlock_fcfs_try_gain_write</strong>(<strong>pthread_rwlock_fcfs_t</strong> * <i>rwlock</i>);</p>
<p><strong>int</strong> <strong>pthread_rwlock_fcfs_timed_gain_read</strong>(<strong>pthread_rwlock_fcfs_t</strong> * <i>rwlock</i>, <strong>const struct timespec</strong> * <i>abstime</i>, <strong>int</strong> (*<i>continue_callback</i>)(<strong>void</strong> * context), <strong>void</strong> * <i>context</i>);</p>
<p><strong>int</strong> <strong>pthread_rwlock_fcfs_timed_gain_write</strong>(<strong>pthread_rwlock_fcfs_t</strong> * <i>rwlock</i>, <strong>const struct timespec</strong> * <i>abstime</i>, <strong>int</strong> (*<i>continue_callback</i>)(<strong>void</strong> * context), <strong>void</strong> * <i>context</i>);</p>
<p><strong>void</strong> <strong>pthread_rwlock_fcfs_release</strong>(<strong>pthread_rwlock_fcfs_t</strong> * <i>rwlock</i>);</p>
<p><strong>void</strong> <strong>pthread_rwlock_fcfs_destroy</strong>(<strong>pthread_rwlock_fcfs_t</strong> * <i>rwlock</i>);</p>

</div>
<h1 id="DESCRIPTION">DESCRIPTION</h1><p><a href="#TOP" class="toplink">Top</a></p>
<div id="DESCRIPTION_CONTENT">
<p>A Readers/Writers Lock (or &quot;rwlock&quot; for short) is a mechanism that allows an 
arbitrary number of readers, or alternatively one and only one writer to 
access a resource at a given time. A First-Come First-Served RWLock makes sure
every pending thread will get its turn eventually.</p>
<p>To create a new rwlock call <strong>pthread_rwlock_fcfs_alloc</strong>(). From then on, more
than one thread can use the lock simultaneously.</p>
<p><strong>pthread_rwlock_fcfs_gain_read</strong> and <strong>pthread_rwlock_fcfs_gain_write</strong> can be
used to gain read or write access for <i>rwlock</i>. They block indefinitely until
the access is granted. They return 0 on success or -1 if the lock is
going to be destroyed and should no longer be accessed.</p>
<p><strong>pthread_rwlock_fcfs_try_gain_read</strong> and <strong>pthread_rwlock_fcfs_try_gain_write</strong>
attempt to gain a read or write permission and if they do not succeed they 
exit immediately. They return 0 upon success, -1 if the lock is going
to be destroyed, and non-zero otherwise.</p>
<p><strong>pthread_rwlock_fcfs_timed_gain_read</strong> and <strong>pthread_rwlock_fcfs_timed_gain_write</strong> 
attempt to gain a permission while initially waiting until <i>abstime</i>. If by 
that time access is not granted, then <i>continue_callback</i> will be called to 
find out if the functions should continue waiting.</p>
<p><i>continue_callback</i> is responsible for setting a new value for <i>abstime</i> and
should return 1 if it wishes to continue wait for a permission or 0 otherwise. 
<i>callback_context</i> is the argument which it receives as an argument.</p>
<p>If <i>continue_callback</i> is set to NULL, then it will be ignored, and the 
function will terminate once the initial wait is over. </p>
<p><strong>pthread_rwlock_fcfs_timed_gain_read</strong> and <strong>pthread_rwlock_fcfs_timed_gain_write</strong> 
return 0 upon success, 1 if they failed to gain a read or write permission
and -1 if the lock is going to be destroyed.</p>
<p><strong>pthread_rwlock_fcfs_release</strong> releases a previously granted 
read or write permission.</p>
<p><strong>pthread_rwlock_fcfs_destroy</strong> can be used to destroy a previously allocated
<i>rwlock</i>.</p>

</div>
<h1 id="ASYNC_SIGNAL_SAFETY">ASYNC-SIGNAL SAFETY</h1><p><a href="#TOP" class="toplink">Top</a></p>
<div id="ASYNC_SIGNAL_SAFETY_CONTENT">
<p>These RWLock functions are not async-signal safe, and should not be called
from a signal handler.</p>

</div>
<h1 id="RETURN_VALUE">RETURN VALUE</h1><p><a href="#TOP" class="toplink">Top</a></p>
<div id="RETURN_VALUE_CONTENT">
<p>All the rwlock functions return 0 on success, -1 if the rwlock is going
to be destroyed, and a non-zero error code on error.</p>

</div>
<h1 id="AUTHOR">AUTHOR</h1><p><a href="#TOP" class="toplink">Top</a></p>
<div id="AUTHOR_CONTENT">
<p>Shlomi Fish &lt;shlomif@vipe.technion.ac.il&gt;.</p>

</div>
<h1 id="EXAMPLE">EXAMPLE</h1><p><a href="#TOP" class="toplink">Top</a></p>
<div id="EXAMPLE_CONTENT">
<p>See the <cite>test_rwlock.c</cite> file inside the pthreads' FCFS RWLock distribution.</p>

</div>
</div></body>
</html>
